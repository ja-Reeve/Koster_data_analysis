######################################## Select SNPs for SNP-panel ########################################
### This script identifies SNPs to include in a SNP-panel which will detect inversions in Swedish Littorina 
### saxatilis. There are four different types of SNP marker which will be included in this panel:
###       1. Koster WGS inversion markers [Eva Koch & James Reeve 2021]
###       2. 10 Random SNPs from LGC14.3 [James Reeve 2022]
###       3. Inversion diagnostic markers from Parrallelogram approach [Westram et al. 2023, BioRxiv]
###       4. Outlier SNPs outside inversions from CZ-cline analysis [Westram et al. 2018, Evolution Letters]
###       5. Koster WGS genetic background markers [James Reeve 2021]
### The selection process for each type of marker will be discussed below

### James Reeve - University of Gothenburg
### 14/12/2021

### Preparation
rm(list = ls())
dev.off()
setwd("~")

### Packages
library(tidyverse)

### Parameters and filepaths
Invs <- unique(read.csv("/input/dir/Inversion_positions_on_old_map.csv", header = T)$INV)
PATH <- "/input/dir/"

### Add linkage group information
LMap <- read.table("/Users/james/Documents/Inversion_detection/map_v11.txt", header = TRUE)
LMap$LG <-  paste0("LG", LMap$LG)

### 1. Inversion markers (Koster WGS) ####
### These markers come from a WGS dataset of 99 snails which were randomly collected from different islands 
### in the Kosterhavets region of Western Sweden. The WGS data was used to find inversions, by a PCA on genotypes 
### within the inverted regions published in Westram et al. 2021 and four new inversions on LG12 which were
### classified by Katie Heard. The genotypes of each SNP were then compared to PC1 scores for each inversion to 
### identify diagnostic markers. This script selects the 10 SNPs with the highest PC1 score on each inversion, and
### an additional 10 from LGC6.1/2 & LGC14.1/2 which the highest correlation to PC2. Note: LGC14.1/2 was shortened 
### on the right hand side by 2.7cM to avoid overlap with LGC14.3.

### Access SNP marker data
select.markers_Koster.Inversions <- function(inversion){
  ## Identify if LGC6.1/2 or LGC14.1/2 
  if(inversion %in% c("LGC6.1/2", "LGC14.1/2")){
    
    # Replace "/" in inversion name with "."
    inversion <- gsub("/", ".", inversion)
    # Load PCA coorleation scores
    tmp <- read.table(paste0(PATH, "Evas_diagnostic_SNPs/", inversion, "Marker.txt"))
    # Add column for SNP ID
    tmp$SNP <- rownames(tmp)
    # Select 10 best SNPs by correlation with PC1
    tmp2 <- head(tmp[order(abs(tmp$PC1), decreasing = TRUE),], 10)
    # Select 10 best SNPs by correlation with PC2
    tmp3 <- head(tmp[order(abs(tmp$PC2), decreasing = TRUE),], 10)
    # Remove any overlaps from tmp3
    tmp3 <- tmp3[!(tmp2$SNP %in% tmp3$SNP),]
    # Merge and return SNPs
    snps <- c(tmp2$SNP, tmp3$SNP)
    res <- snps
    
  } else {  ## Select by just correlations on PC1
    # PCA correlation scores for each inversions
    tmp <- read.table(paste0(PATH, "Evas_diagnostic_SNPs/", inversion, "Marker.txt"))
    tmp$SNP <- rownames(tmp)
    # Sort by PC1 correlation in descending order regardless of sign and select top 10
    tmp2 <- head(tmp[order(abs(tmp$PC1), decreasing = TRUE),], 
                 ifelse(inversion == "LGC14.3", 5, 10)) # Only sample 5 SNPs for LGC14.3 - see next section
    return(tmp2$SNP)
    
  }
}

KT_inv <- lapply(Invs, select.markers_Koster.Inversions)
names(KT_inv) <- Invs



### 2. Random markers on LGC14.3 ####
### Upon closer inspection, most of the markers for LGC14.3 were packed on the left side of the inversion, close to the 
### boundary with LGC14.1/2. Since LGC14.3 covers a large part of LG14, this left a large part of the genome 
### unrepresented. To fix this problem 10 SNPs will be randomly selected over different contigs which map between 12 - 35cM.

### Access the data for LGC14.3
tmp <- read.table(paste0(PATH, "Evas_diagnostic_SNPs/LGC14.3Marker.txt"))
# Add column for SNP ID
tmp$SNP <- rownames(tmp)
# Create contig column
tmp$contig <- gsub("_.*", "", tmp$SNP)

### Find map positions of each marker - matching by contig
# Note: a few contigs map to multiple map positions
tmp2 <- left_join(tmp, LMap, by = "contig") %>%
  select(PC1, PC2, SNP, av) %>% distinct()

### Subset to right side of LGC14.3
tmp2 <- tmp2 %>% filter(av > 12 & av < 35)

### Randomly sample markers
GB14.3 <- tmp2 %>% 
  # Select 1 random SNP per map positions
  group_by(av) %>%
  slice_sample(n = 1) %>%
  # Select N random SNPs
  ungroup() %>%
  slice_sample(n = 10)

rm(tmp, tmp2)



### 3. Inversion markers (parallelograms) ####
### These markers are diagnostic of crab-wave divergence in Spain, Sweden and the UK. They were generated by Anja Westram 
### using an approach that seeks the maximum allele frequency differences in Pool-seq data. Anja specifically excluded 
### LG12 and LG14 from her analysis due to the complex patterns of recombination on these linkage groups. I further 
### filtered this data to downsample to a handful of SNPs per inversion.

### Access diagnostic markers
select.markers_paralleogram <- function(inversion){
  
  ## Load list of parallelogram diagnostic markers
  # This uses the try() function to skip any inversion which weren't tested by Anja
  tmp_A <- try(read.table(
    paste0(PATH,"Anjas_diagnostic_SNPs/PAR003_DIAG_A_", 
           # Change notation for LGC6.1/2
           if(inversion == "LGC6.1/2"){gsub("/", "-", inversion)} else {inversion},
           ".txt"), skip = 1)$V1, 
    silent = TRUE)
  if("try-error" %in% class(tmp_A)) {tmp_A <-  c()}
  
  tmp_B <- try(read.table(
    paste0(PATH,"Anjas_diagnostic_SNPs/PAR003_DIAG_B_", 
           if(inversion == "LGC6.1/2"){gsub("/", "-", inversion)} else {inversion},
           ".txt"), skip = 1)$V1, 
    silent = TRUE)
  if("try-error" %in% class(tmp_B)) {tmp_B <-  c()}
  
  # Merge diagnostic SNPs from separate inversion arrangements
  tmp <- c(tmp_A, tmp_B)
  if(length(tmp) == 0){tmp <-  NA}
  
  ## Remove any overlaps with the Koster inversion markers
  tmp2 <- tmp[!(tmp %in% KT_inv[[inversion]])]
  
  ## Find if mulitple markers are on the same contig
  contigs <- gsub("_.*", "", tmp)
  N_per_contig <- table(contigs)
  
  ## Select 1 random marker per contig
  tmp3 <- sapply(names(N_per_contig), function(X){
    if(N_per_contig[X] > 1){
      sample(tmp2[contigs == X], 1)
    } else {
      tmp2[contigs == X]
    }
  })
  tmp3 <- as.character(tmp3)
  return(tmp3)
}

Para_inv <- lapply(Invs, select.markers_paralleogram)

# Remove elements missing data
Missing <- which(lapply(Para_inv, length) == 0)

Para_inv <- Para_inv[-c(Missing)]
names(Para_inv) <- Invs[-c(Missing)]



### 4. Non-inversion outliers ####
### These SNPs come direct from an older SNP dataset used in the ERC project. This SNP data was collated from several even 
### older SNP sets. For the current SNP panel design, we are only using the "collinear outliers". These outlier markers 
### indicate SNPs outside inversions which had a strong cline in allele frequencies between the crab and wave ecotypes in 
### Sweden. This analysis was conducted by Westram et al. 2018, Evolution Letters. To design the current SNP panel, the old 
### SNP panel is subsetted to just markers which contain "collinear_inversion" in their names. As a sanity check, these are 
### then compared to the two inversion marker sets to ensure that there are no overlaps. Finally, I removed any SNPs on LG12,
### as these outliers were established before we found the two new inversions on LG12 (Hearn et al. 2022, Evolution Letters).

### Access 5000 SNP dataset
SNP5000 <- read.table(paste0(PATH,"Old_SNP_design/Butlin_ERC_BED_Feb_5_2020.txt"))

### Select just Anja's non-inversion [colinear] outliers
tmp <- SNP5000[grepl(pattern = "colinear_inversion", SNP5000$V4),]
Non_inv <- tmp[!(grepl(pattern = "_12_", tmp$V4)),]
### Save SNP names as new column
Non_inv$SNP <- paste(Non_inv$V1, Non_inv$V3, sep = "_")

### Check 1: no overlaps with Koster data
summary(unlist(lapply(KT_inv, function(X) X %in% Non_inv$SNP)))

### Check 2: no overlaps with paralleogram data
summary(unlist(lapply(Para_inv, function(X) X %in% Non_inv$SNP)))


                      
### 5. Genetic background markers ####
### These SNPs were selected using a hierarchically-random approach. Firstly the SNPs from the Koster data are mapped to the 
### linkage map. Any SNPs mapped between inversion breakpoints are removed, including a 2cM buffer on either side of the 
### breakpoints to minimise any linkage effects with the inversion. The remaining sites were then randomly sampled to select 
### N contigs and then 1 random SNP per contig, where N = the number of remaining SNPs not used in the previous dataset. 

### Note: this is a complex chunk of code. To keep things simple, I wrote this in a different R script, "SNP_panel_genetic_background.R".
### This script requires the number of remaining SNPs to determine how many genetic background SNPs are selected.

### Calculate the number of SNPs remaining
N <- 1000 - 
  (sum(sapply(KT_inv, length)) +
  nrow(GB14.3) +
  sum(sapply(Para_inv, length)) +
  nrow(Non_inv))

### Access output of "SNP_panel_genetic_background.R"
GB <- read.table(paste0(PATH, "Genetic_background_SNPs_N", N, "_2cM_buffer", ".txt"), header = TRUE)



### 5. Merge different datasets into a .bed file ####

### Inversion markers (Koster WGS)
tmp <- lapply(Invs, function(i){
  LG <- gsub("C", "", gsub("[.].*", "", i)) # Get linkage group
  lmap <- LMap[LMap$LG == LG,] # Filter linkage map
  contigs <- gsub("_.*", "", KT_inv[[i]]) # Contigs in Koster inversion data
  mpos <- sapply(contigs, function(X){ # Assign map position for each contig
    mean(lmap[lmap$contig == X, "av"])}) # Use the average when there's multiple map positions
  
  data.frame("CHROM" = contigs,
             "START_POS" = as.numeric(gsub(".*_", "", KT_inv[[i]])) - 1,
             "END_POS" = as.numeric(gsub(".*_", "", KT_inv[[i]])),
             "NAME" = paste0(KT_inv[[i]], "_", LG, "_", round(mpos, 1), "cM_Koster_inversion_", i, "_Eva"))
})
SNP_panel.1 <- do.call(rbind.data.frame, tmp)

### Random markers on LGC14.3
SNP_panel.2 <- data.frame("CHROM" = gsub("_.*", "", GB14.3$SNP),
                          "START_POS" = as.numeric(gsub(".*_", "", GB14.3$SNP)) - 1,
                          "END_POS" = as.numeric(gsub(".*_", "", GB14.3$SNP)),
                          "NAME" = paste0(GB14.3$SNP, "_LG14_", round(GB14.3$av, 1), 
                                          "cM_Koster_background_LGC14.3_James"))

### Inversion markers (parallelograms)
tmp <- lapply(Invs[-c(Missing)], function(i){
  LG <- gsub("C", "", gsub("[.].*", "", i)) # Get linkage group
  lmap <- LMap[LMap$LG == LG,] # Filter linkage map
  contigs <- gsub("_.*", "", Para_inv[[i]]) # Contigs in parallelogram data
  mpos <- sapply(contigs, function(X){ # Assign map position for each contig
    mean(lmap[lmap$contig == X, "av"])}) # Use the average when there's multiple map positions
  
  data.frame("CHROM" = gsub("_.*", "", Para_inv[[i]]),
             "START_POS" = as.numeric(gsub(".*_", "", Para_inv[[i]])) - 1,
             "END_POS" = as.numeric(gsub(".*_", "", Para_inv[[i]])),
             "NAME" = paste0(Para_inv[[i]], "_", LG, "_", round(mpos, 1), 
                             "cM_Paralleogram_inversion_", i, "_Anja"))
})
SNP_panel.3 <- do.call(rbind.data.frame, tmp)

### Non-inversion outliers
tmp <- strsplit(Non_inv$V4, split = "_")
SNP_panel.4 <- data.frame("CHROM" = Non_inv$V1,
                          "START_POS" = Non_inv$V2,
                          "END_POS" = Non_inv$V3,
                          "NAME" = paste0(Non_inv$V1, "_", Non_inv$V3, "_",
                                          "LG", sapply(tmp, `[[`, 3), "_",
                                          sapply(tmp, `[[`, 4), "cM",
                                          "_colinear_outliers_Anja"))

### Genetic background markers
SNP_panel.5 <- data.frame("CHROM" = GB$contig,
                          "START_POS" = as.numeric(gsub(".*_", "", GB$SNP)) - 1,
                          "END_POS" = as.numeric(gsub(".*_", "", GB$SNP)),
                          "NAME" = paste0(GB$SNP, "_", GB$LG, "_", round(GB$av, 1), 
                                          "cM_colinear_genetic_background_James"))

SNP_panel <- rbind.data.frame(SNP_panel.1, SNP_panel.2, SNP_panel.3, SNP_panel.4, SNP_panel.5)

### Sort and save
SNP_panel <- SNP_panel %>% arrange(as.numeric(gsub(".*g","",CHROM)), END_POS)

write.table(SNP_panel, paste0(PATH,"Koster_SNP_panel_", Sys.Date(), ".bed"), row.names = FALSE, col.names = FALSE, quote = FALSE)


